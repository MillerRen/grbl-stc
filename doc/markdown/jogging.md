# Grbl v1.1 点动

本文档概述了如何使用 Grbl v1.1 的新点动命令。这些命令之所以不同，是因为它们可以被取消，并且所有排队的运动都可以通过简单的点动取消或进给保持实时命令自动清除。Jogging 命令不会以任何方式改变 g 代码解析器的状态，因此如果您记得在开始工作之前将距离模式设置回“G90”，您就不必再担心了。此外，点动与模拟操纵杆和旋转拨盘配合得很好！请参阅下面的实施说明。

## 如何使用
执行点动需要特定的命令结构，如下所述：

 - 前三个字符必须是 '$J=' 以指示点动。
 - 点动命令紧跟在“=”之后，就像普通的 G1 命令一样工作。
 - 进给率仅以每分钟 G94 单位解释。在点动期间忽略先前的 G93 状态。
 - 必填词：
   - XYZ：一个或多个具有目标值的轴字。
   - F - 进给率值。注意：每个点动都需要此值，并且不被视为模态。
 - 可选词：点动根据当前 G20/G21 和 G90/G91 g 代码解析器状态执行。如果传递了以下可选词之一，则仅针对一个命令覆盖该状态。
   - G20 或 G21 - 英寸和毫米模式
   - G90 或 G91 - 绝对和增量距离
   - G53 - 在机器坐标中移动
   - N 行号有效。如果启用，将显示在报告中，否则将被忽略。
 - 所有其他 g 代码、m 代码和值字（包括 S 和 T）在 jog 命令中不被接受。
 - 命令中允许有空格和注释。这些由预解析器删除。

 - 示例：G21 和 G90 是点动前的有效模态状态。这些是顺序命令。
    - `$J=X10.0 Y-1.5` 将在工作坐标系 (WPos) 中移动到 X=10.0mm 和 Y=-1.5mm。
    - `$J=G91 G20 X0.5` 将移动 +0.5 英寸（12.7 毫米）到 X=22.7 毫米（WPos）。注意 G91 和 G20 只适用于该点动指令。
    - `$J=G53 Y5.0` 将机器移动到机器坐标系 (MPos) 中的 Y=5.0mm。如果 y 轴的工件坐标偏移为 2.0 毫米，则 Y 为 3.0 毫米（WPos）。

点动命令的行为与普通的 g 代码流几乎相同。每个点动命令都会,当点动运动被解析并准备执行时返回“ok”。如果一个命令无效，Grbl 将返回“错误：”。多个点动命令可能是依次排队。

主要区别是：  

- 在点动期间，Grbl 将在执行点动时报告“点动”状态。
- 只有当 Grbl 处于“空闲”或“点动”状态时才会接受点动命令。
- 执行时不能将点动运动与 g 代码命令混合，如果尝试，这将返回锁定错误。
- 可以随时使用简单的点动取消实时命令或进给保持或安全门事件取消所有点动运动。Grbl 将自动刷新任何排队的点动运动的 Grbl 内部缓冲区并返回到“空闲”状态。无需软复位。
- 如果启用软限位，超出机器行程的点动命令不会执行命令并返回错误，而不是在正常操作中发出警报。
- 重要提示：点动不会改变 g 代码解析器状态。因此，不需要显式管理 g 代码模式，这与以前使用“G91G1X1F100”等命令实现点动的方式不同。由于 G91、G1 和 F 进给率是模态的，如果在恢复/开始工作之前没有将它们改回来，工作可能无法按预期运行并导致崩溃。

------

## 操纵杆实现

Grbl v1.1 中的点动通常旨在解决旧的自举点动方法的一些先前问题。不幸的是，新的 Grbl 点动并不是一个完整的解决方案。闪存和内存限制阻止了最初设想的实现，但其中大部分都可以通过以下建议的方法来模拟。

结合新的点动取消和“G91”增量模式移动，以下实现可以为模拟操纵杆或类似的控制设备创造低延迟的感觉。

- 基本实现概述： 
  - 创建一个循环来读取操纵杆信号并将其转换为所需的点动运动矢量。
  - 向 Grbl 发送一个非常短的 `G91` 增量距离点动命令，其进给率基于操纵杆投掷。
  - 在重新启动循环之前等待“确定”确认。
  - 不断读取操纵杆输入并发送 Grbl 短的点动动作，以保持 Grbl 的规划器缓冲区已满。
  - 如果操纵杆返回到中立位置，停止点动循环并简单地向 Grbl 发送点动取消实时命令。这将在几乎零延迟的情况下沿着编程的点动路径立即停止运动，并自动刷新 Grbl 的计划器队列。不建议使用进给暂停来取消点动，因为如果在返回 IDLE 状态后发送 Grbl，它可能会导致无意中挂起 Grbl。


总体思路是最小化规划器队列中的总距离，为操纵杆控制提供低延迟的感觉。主要技巧是确保计划队列中有足够的距离，以便始终满足编程的进给率。稍后将解释如何计算它。在实践中，大多数机器会有 0.5-1.0 秒的延迟。当与立即点动取消命令结合使用时，操纵杆交互可以非常愉快和令人满意。

但是，请注意，如果机器具有低加速度并且被要求以高编程进给速率移动，则操纵杆延迟可能会达到几秒钟。这听起来可能很糟糕，但这是低加速度机器以高进给率运行，减速到停止所需的时间。可以为低加速度机器提出论点，你真的不应该以高进给率点动。用户很难判断机器将在何处停止。您冒着超出目标目的地的风险，这可能导致代价高昂或危险的撞车事故。

这种方法的优点之一是 GUI 可以通过它已经发送给 Grbl 的点动命令确定性地跟踪 Grbl 将去哪里。只要不取消点动，就保证每个点动命令都会执行。在调用点动取消的情况下，GUI 只需要在 Grbl 清除计划器缓冲区并从点动状态返回到空闲（或门，如果半开）状态后，从状态报告中刷新其内部位置。该停止位置将始终位于编程的点动路径上的某个位置。如果需要，可以使用新的跟踪路径快速轻松地重新开始点动。

结合机器坐标中的“G53”移动，GUI 可以限制点动进入机器空间内的“禁止”区域。这对于避免撞到精密的探测硬件、工件夹持机构或您想要避免的机器空间内的其他固定功能非常有用。

#### 如何计算增量距离

确定最小化延迟所需的点动运动长度的最快和最简单的方法由以下等式定义。

`s = v * dt` - 计算下一个点动命令的行进距离。

在哪里：  

- `s` - 点动命令的增量距离。
- `dt` - 单个点动命令的估计执行时间（以秒为单位）。  
- `v` - 当前点动进给速度以 **mm/sec** 为单位，而不是 mm/min。小于或等于最大点动速率。
- `N` - Grbl 规划器块的数量（`N=15`）
- `T = dt * N` - 以秒为单位计算总估计延迟。
 
时间增量 `dt` 可以定义为您需要的任何值。显然，您需要最低的值，因为这会转化为更低的整体延迟“T”。但是，它受到两个因素的限制。

- `dt > 10ms` - Grbl 解析和计划一个 jog 命令并接收下一个命令所花费的时间。取决于很多因素，这可能在 1 到 5 毫秒左右。为保守起见，使用“10ms”。请记住，在某些系统上，由于往返通信延迟，此值可能仍大于“10ms”。

- `dt > v^2 / (2 * a * (N-1))` - 时间增量需要足够大以确保实现点动进给率。Grbl 总是计划在计划器缓冲区中排队的总距离上停留。这主要是为了确保机器在断开连接时能够安全停止。这个等式只是确保 `dt` 足够大来满足这个约束。

	- 为简单起见，使用以 mm/sec 为单位的 `v` 的最大点动进给速率和以 mm/sec^2 为单位移动的点动轴之间的最小加速度设置。

	- 为了降低延迟，可以为每个点动运动计算 `dt`，其中 `v` 是当前速率，`a` 是沿着点动矢量的最大加速度。如果以非常慢的速度行驶以定位零零件，这将非常有用。在这种情况下，`v` 速率会低得多，总延迟会呈二次方下降。

在实践中，大多数 CNC 机器将以“0.025 秒”<“dt”<“0.06 秒”的点动时间增量运行，这相当于以最大点动速度行驶时大约“0.4”到“0.9”秒的总延迟. 对大多数人来说已经足够了。

但是，如果以较慢的速度点动并且 GUI 用它调整 `dt`，您可以通过人机界面指南获得非常接近 0.1 秒响应时间的“感觉瞬间”。不是太寒酸！

凭借一些独创性，这种点动方法可以应用于不同的设备，例如旋转拨号或触摸屏。“惯性感觉”，如在智能手机或平板电脑上滑动滚动，可以通过管理慢速衰减并向 Grbl 发送相关的慢速命令来模拟。虽然这种点动实现需要 GUI 进行更多的初始工作，但它本质上也更加灵活，因为您可以完全确定地控制点动的行为方式。
